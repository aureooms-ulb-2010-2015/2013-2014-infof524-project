model "mcndp/raw"
	uses "mmxprs"

	(! parameters !)

	parameters
		DATA = ""                            ! input file name, if "" read from stdin
	end-parameters


	(! forward !)

	forward procedure column_gen


	include "mcndp/lib/cg-parse.mos"
	include "mcndp/lib/cg-sp.mos"

	declarations
		l     : integer                          ! # of generated paths per product
		Pr    : range                            ! Path range
		DELTA : array(Kr, Pr, Mr) of integer     ! Tells if path P contains arc _m_
		FLOW  : array(Kr, Pr) of mpvar           ! Flow decision variables
		EPS   = 1e-6                             ! Zero tolerance

		solFlow   : array(Kr, Pr) of real        ! Solution values for variables 'FLOW'
		Link      : array(Kr, Mr) of linctr      ! Variable change linking
		Flow      : array(Kr) of linctr          ! Flow constraints
		Capacity  : array(Mr) of linctr          ! Capacity constraints
		Bound     : array(Kr, Mr) of linctr      ! Bound constraints
		TotalCost : linctr                       ! Objective function
	end-declarations

	l  := 1
	Pr := 1..l

	(! generate basis !)

		forall(k in Kr) do
			create(FLOW(k, l))                   ! Create flow variable
			FLOW(k,l) is_integer
			DELTA(k, l, M + k) := 1              ! Basic paths only use dummy arcs
		end-do


	(! objective !)

	TotalCost :=
		sum (m in Mr) (F(m) * Y(m)) +
		sum (m in Mr, k in Kr, p in Pr | exists(X(k, m))) (C(k, m) * DELTA(k, p, m) * FLOW(k, p))
		

	(! constraints !)

	! Link

		forall(m in Mr, k in Kr | exists(X(k, m)))
		Link(k, m) := sum (p in Pr) DELTA(k, p, m) * FLOW(k, p) = X(k, m)


	! Flows

		forall (k in Kr)
		Flow(k) := sum (p in Pr) FLOW(k, p) = D(k)


	! Capacity

		forall (m in Mr)
		Capacity(m) := sum (k in Kr, p in Pr) DELTA(k, p, m) * FLOW(k, p) <= U(m) * Y(m)


	! Bound

		forall (m in Mr, k in Kr | exists(X(k, m)))
		Bound(k, m) := sum(p in Pr) DELTA(k, p, m) * FLOW(k, p) <= B(k, m) * Y(m)


	! Quantities

		forall (m in Mr, k in Kr | exists(X(k, m)))
		X(k, m) >= 0


	! Open

		forall (m in Mr | exists(Y(m)))
		Y(m) is_binary


	(! solve !)

		column_gen
		minimize(TotalCost)



	
	(! output !)

	include "mcndp/lib/cg-output.mos"



	(! method !)

	procedure column_gen

 		declarations
			dualFlow          : array(Kr) of real                    ! Flow constraints dual variables
			dualCapacity      : array(Wr) of real                    ! Capacity constraints dual variables
			dualBound         : array(Kr, Wr) of real                ! Bound constraints dual variables

 			GAMMA             : array(Kr, Nr, Nr) of real            ! sp costs
 			LAMBDA            : array(Kr, Nr, Nr) of integer         ! sp output
 			XI                : dynamic array(Kr, Nr, Nr) of mpvar   ! sp coefficients
 			Z                 : array(Kr) of real                    ! sp solutions
 			done              : boolean                      

 			reducedCost       : array(Kr, Wr) of real                ! arcs reduced costs
 			dw, zbest, objval : real
 			bas               : basis
 		end-declarations


 		defcut := getparam("XPRS_CUTSTRATEGY") ! Save setting of ‘CUTSTRATEGY’
 		setparam("XPRS_CUTSTRATEGY", 0)        ! Disable automatic cuts
 		setparam("XPRS_PRESOLVE", 0)           ! Switch presolve off
 		setparam("zerotol", EPS)               ! Set comparison tolerance of Mosel

 		forall (k in Kr, m in Wr) create(XI(k, I(m), J(m)))

 		while(true) do
			minimize(XPRS_LIN, TotalCost)
 			savebasis(bas)                                               ! Save the current basis
 			objval := getobjval                                          ! Get the objective value
 			forall(k in Kr, p in Pr) solFlow(k, p) := getsol(FLOW(k, p)) ! Get the solution values
 
 			writeln(" > sol : ", objval, " cost, ", l, " paths per product")
 
 			forall (k in Kr) dualFlow(k) := getdual(Flow(k))
 			forall (m in Wr) dualCapacity(m) := getdual(Capacity(m))
 			forall (k in Kr, m in Wr) dualBound(k, m) := getdual(Bound(k, m))
 			forall (k in Kr, m in Wr) do
 				reducedCost(k, m)    := C(k, m) - dualCapacity(m) - dualBound(k, m)
 				GAMMA(k, I(m), J(m)) := reducedCost(k, m)
 			end-do

 			forall (k in Kr) do
 				writeln("compute sp for product #", k)
 				Z(k) := sp(GAMMA, XI, LAMBDA, Nr, S(k), T(k), k)
 				writeln("found path with value : ", Z(k))
 			end-do

 			done := true
 			forall (k in Kr) do
 				if (Z(k) < dualFlow(k)) then
 					done := false
 					break
 				end-if
 			end-do

 			if done = true then
 				writeln("no profitable column found.\n")
 				break
 			else
 				l += 1                     ! inc. path index

				forall(k in Kr) do
					create(FLOW(k, l))                          ! Create flow variable
					FLOW(k,l) is_integer

					forall(m in Wr) do
						DELTA(k, l, m) := LAMBDA(k, I(m), J(m)) ! Copy path arc list

						(! upgrade objective !)

						TotalCost += C(k, m) * DELTA(k, l, m) * FLOW(k, l)
							
						(! upgrade constraints !)
			
						Link(k, m)  += FLOW(k, l) * DELTA(k, l, m)
						Flow(k)     += FLOW(k, l)
						Capacity(m) += FLOW(k, l) * DELTA(k, l, m)
						Bound(k, m) += FLOW(k, l) * DELTA(k, l, m)

					end-do
				end-do


! 				loadprob(TotalCost)               ! Reload the problem
! 				loadbasis(bas)                    ! Load the saved basis

 			end-if
 
 			writeln
		end-do


		setparam("XPRS_CUTSTRATEGY", defcut) ! Enable automatic cuts
		setparam("XPRS_PRESOLVE", 1)         ! Switch presolve on
			
			
	end-procedure

end-model